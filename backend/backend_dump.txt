===============================
C:\Proyectos en desarrollo\credit-analysis\backend\alembic.ini
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\requirements.txt
===============================
fastapi==0.115.0
uvicorn[standard]==0.30.6

SQLAlchemy==2.0.34
psycopg2-binary==2.9.9

pydantic==2.9.2
pydantic-settings==2.5.2

python-jose==3.3.0
passlib[bcrypt]==1.7.4

python-multipart==0.0.9
email-validator==2.2.0
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\alembic\env.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\main.py
===============================
from fastapi import FastAPI
from app.api.v1.router import api_router

app = FastAPI(title="Credit Analysis API")

app.include_router(api_router, prefix="/api/v1")
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\deps.py
===============================
from app.db.session import SessionLocal

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\admin.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\analyses.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\auth.py
===============================
import secrets
import uuid
from datetime import datetime, timedelta, timezone

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.api.deps import get_db
from app.core.config import settings
from app.core.security import hash_password, verify_password, create_access_token
from app.models.user import Usuario
from app.models.otp import VerificacionOTP
from app.repositories.users_repo import UsersRepo
from app.repositories.otp_repo import OtpRepo
from app.services.email_otp_service import EmailOtpService
from app.schemas.auth import (
    RegisterRequest,
    RegisterResponse,
    VerifyOtpRequest,
    LoginRequest,
    TokenResponse,
)

router = APIRouter()


@router.post("/register", response_model=dict)
def register(payload: RegisterRequest, db: Session = Depends(get_db)):
    users = UsersRepo(db)

    # Validaciones de unicidad
    if users.get_by_email(str(payload.email)):
        raise HTTPException(status_code=409, detail="El email ya estÃ¡ registrado.")
    if users.get_by_identificacion(payload.identificacion):
        raise HTTPException(status_code=409, detail="La identificaciÃ³n ya estÃ¡ registrada.")

    # Crear usuario
    user = Usuario(
        nombres=payload.nombres,
        primer_apellido=payload.primer_apellido,
        segundo_apellido=payload.segundo_apellido,
        tipo_identificacion=payload.tipo_identificacion,
        identificacion=payload.identificacion,
        email=str(payload.email),
        telefono=payload.telefono,
        genero=payload.genero,
        password_hash=hash_password(payload.password),
        ciudad_id=payload.ciudad_id,
        status="PENDING",
        email_verificado=False,
    )

    user = users.create_user(user)
    users.ensure_role_assignment(user.id, "CLIENT")

    # Crear OTP
    code = f"{secrets.randbelow(1_000_000):06d}"
    expires = datetime.now(timezone.utc) + timedelta(minutes=settings.OTP_EXPIRE_MINUTES)

    otp_repo = OtpRepo(db)
    otp = VerificacionOTP(
        user_id=user.id,
        code_hash=hash_password(code),
        tipo="EMAIL",
        status="PENDING",
        expires_at=expires,
        used_at=None,
    )
    otp_repo.create(otp)

    # Asignar rol CLIENT
    try:
        users.ensure_role_assignment(user.id, "CLIENT")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error asignando rol CLIENT: {str(e)}")

    # Enviar email
    try:
        EmailOtpService().send_otp(to_email=str(payload.email), code=code)
    except Exception:
        raise HTTPException(status_code=500, detail="No se pudo enviar el OTP al correo.")

    return RegisterResponse(
        user_id=str(user.id),
        status=user.status,
        message="Usuario creado en estado PENDING. Verifica el OTP enviado al correo para activar tu cuenta.",
    ).model_dump()


@router.post("/verify-otp", response_model=dict)
def verify_otp(payload: VerifyOtpRequest, db: Session = Depends(get_db)):
    users = UsersRepo(db)
    otp_repo = OtpRepo(db)

    # Parse user_id a UUID
    try:
        user_id = uuid.UUID(payload.user_id)
    except Exception:
        raise HTTPException(status_code=400, detail="user_id invÃ¡lido.")

    user = users.get_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no existe.")

    otp = otp_repo.get_pending(user_id=user.id, tipo="EMAIL")
    if not otp:
        raise HTTPException(status_code=400, detail="No hay OTP pendiente para este usuario.")

    now = datetime.now(timezone.utc)

    if otp.expires_at and now > otp.expires_at:
        otp.status = "EXPIRED"
        otp_repo.save(otp)
        raise HTTPException(status_code=400, detail="OTP expirado. Solicita uno nuevo.")

    if not otp.code_hash or not verify_password(payload.code, otp.code_hash):
        raise HTTPException(status_code=400, detail="OTP incorrecto.")

    otp.status = "VERIFIED"
    otp.used_at = now
    otp_repo.save(otp)

    user.email_verificado = True
    user.status = "ACTIVE"
    db.add(user)
    db.commit()
    db.refresh(user)

    return {"message": "Cuenta verificada. Ya puedes iniciar sesiÃ³n.", "status": user.status}


@router.post("/login", response_model=dict)
def login(payload: LoginRequest, db: Session = Depends(get_db)):
    users = UsersRepo(db)
    user = users.get_by_identificacion(payload.identificacion)

    if not user or not user.password_hash or not verify_password(payload.password, user.password_hash):
        raise HTTPException(status_code=401, detail="Credenciales invÃ¡lidas.")

    if user.status != "ACTIVE" or not user.email_verificado:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cuenta no activa. Verifica tu correo con OTP.",
        )

    token = create_access_token(subject=str(user.id))
    return TokenResponse(access_token=token).model_dump()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\documents.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\router.py
===============================
from fastapi import APIRouter
from app.api.v1.auth import router as auth_router

api_router = APIRouter()
api_router.include_router(auth_router, prefix="/auth", tags=["auth"])
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\users.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\config.py
===============================
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str

    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    OTP_EXPIRE_MINUTES: int = 10

    SMTP_HOST: str
    SMTP_PORT: int = 587
    SMTP_USER: str
    SMTP_PASSWORD: str
    SMTP_FROM_NAME: str = "Credit Analysis"
    SMTP_FROM_EMAIL: str

    APP_PUBLIC_NAME: str = "Credit Analysis"

    class Config:
        env_file = ".env"


settings = Settings()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\exceptions.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\logging.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\security.py
===============================
from datetime import datetime, timedelta, timezone
from jose import jwt
from passlib.context import CryptContext
from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


def create_access_token(subject: str) -> str:
    expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    payload = {"sub": subject, "exp": expire}
    return jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\db\base.py
===============================
from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    pass
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\db\session.py
===============================
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\analisis.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\auditoria.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\banco.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\documento.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\opcion_abono.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\otp.py
===============================
import uuid
from sqlalchemy import String, DateTime, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class VerificacionOTP(Base):
    __tablename__ = "verificaciones_otp"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, server_default=text("gen_random_uuid()"))
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("usuarios.id", ondelete="CASCADE"), nullable=False)

    code_hash: Mapped[str | None] = mapped_column(String(255))
    tipo: Mapped[str | None] = mapped_column(String(20))  # EMAIL
    status: Mapped[str] = mapped_column(String(20), server_default=text("'PENDING'"))  # PENDING/VERIFIED/EXPIRED

    expires_at: Mapped[str | None] = mapped_column(DateTime(timezone=True))
    used_at: Mapped[str | None] = mapped_column(DateTime(timezone=True))
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\propuesta.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\role.py
===============================
import uuid
from sqlalchemy import String, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class Role(Base):
    __tablename__ = "roles"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    code: Mapped[str | None] = mapped_column(String(30), unique=True)
    name: Mapped[str | None] = mapped_column(String(80))


class UsuarioRole(Base):
    __tablename__ = "usuario_roles"

    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("usuarios.id", ondelete="CASCADE"), primary_key=True)
    role_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("roles.id", ondelete="CASCADE"), primary_key=True)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\user.py
===============================
import uuid
from sqlalchemy import String, Boolean, DateTime, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class Usuario(Base):
    __tablename__ = "usuarios"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, server_default=text("gen_random_uuid()"))
    nombres: Mapped[str | None] = mapped_column(String(150))
    primer_apellido: Mapped[str | None] = mapped_column(String(80))
    segundo_apellido: Mapped[str | None] = mapped_column(String(80))
    tipo_identificacion: Mapped[str | None] = mapped_column(String(10))
    identificacion: Mapped[str | None] = mapped_column(String(30), unique=True)
    email: Mapped[str | None] = mapped_column(String(255), unique=True)
    telefono: Mapped[str | None] = mapped_column(String(30))
    genero: Mapped[str | None] = mapped_column(String(20))
    password_hash: Mapped[str | None] = mapped_column(String(255))

    ciudad_id: Mapped[int | None] = mapped_column(ForeignKey("ciudades.id", ondelete="SET NULL"), nullable=True)

    status: Mapped[str] = mapped_column(String(20), server_default=text("'PENDING'"))
    email_verificado: Mapped[bool] = mapped_column(Boolean, server_default=text("false"))
    created_at: Mapped[str | None] = mapped_column(DateTime(timezone=True), server_default=text("now()"))
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\__init__.py
===============================
from app.models.user import Usuario
from app.models.role import Role, UsuarioRole
from app.models.otp import VerificacionOTP
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\admin_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\analyses_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\documents_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\otp_repo.py
===============================
from sqlalchemy.orm import Session
from sqlalchemy import select
from app.models.otp import VerificacionOTP


class OtpRepo:
    def __init__(self, db: Session):
        self.db = db

    def create(self, otp: VerificacionOTP) -> VerificacionOTP:
        self.db.add(otp)
        self.db.commit()
        self.db.refresh(otp)
        return otp

    def get_pending(self, user_id, tipo: str) -> VerificacionOTP | None:
        return self.db.execute(
            select(VerificacionOTP)
            .where(
                VerificacionOTP.user_id == user_id,
                VerificacionOTP.tipo == tipo,
                VerificacionOTP.status == "PENDING",
            )
            .order_by(VerificacionOTP.expires_at.desc())
        ).scalar_one_or_none()

    def save(self, otp: VerificacionOTP):
        self.db.add(otp)
        self.db.commit()
        self.db.refresh(otp)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\users_repo.py
===============================
from sqlalchemy.orm import Session
from sqlalchemy import select
from app.models.user import Usuario
from app.models.role import Role, UsuarioRole


class UsersRepo:
    def __init__(self, db: Session):
        self.db = db

    def get_by_email(self, email: str) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.email == email)).scalar_one_or_none()

    def get_by_identificacion(self, identificacion: str) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.identificacion == identificacion)).scalar_one_or_none()

    def get_by_id(self, user_id) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.id == user_id)).scalar_one_or_none()

    def create_user(self, user: Usuario) -> Usuario:
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user

    def ensure_role_assignment(self, user_id, role_code: str):
        role = self.db.execute(select(Role).where(Role.code == role_code)).scalar_one_or_none()
        if not role:
            raise ValueError(f"Role {role_code} no existe (seed roles).")

        exists = self.db.execute(
            select(UsuarioRole).where(UsuarioRole.user_id == user_id, UsuarioRole.role_id == role.id)
        ).scalar_one_or_none()

        if not exists:
            self.db.add(UsuarioRole(user_id=user_id, role_id=role.id))
            self.db.commit()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\analisis.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\auth.py
===============================
from pydantic import BaseModel, EmailStr, Field


class RegisterRequest(BaseModel):
    nombres: str = Field(min_length=1, max_length=150)
    primer_apellido: str = Field(min_length=1, max_length=80)
    segundo_apellido: str | None = Field(default=None, max_length=80)

    tipo_identificacion: str = Field(min_length=1, max_length=10)
    identificacion: str = Field(min_length=3, max_length=30)

    email: EmailStr
    telefono: str | None = Field(default=None, max_length=30)
    genero: str | None = Field(default=None, max_length=20)

    password: str = Field(min_length=8, max_length=72)

    ciudad_id: int | None = None


class RegisterResponse(BaseModel):
    user_id: str
    status: str
    message: str


class VerifyOtpRequest(BaseModel):
    user_id: str
    code: str = Field(min_length=4, max_length=12)


class LoginRequest(BaseModel):
    identificacion: str
    password: str


class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\documentos.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\propuestas.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\user.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\calc_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\email_otp_service.py
===============================
import smtplib
from email.mime.text import MIMEText
from app.core.config import settings


class EmailOtpService:
    def send_otp(self, to_email: str, code: str):
        subject = f"{settings.APP_PUBLIC_NAME} - CÃ³digo de verificaciÃ³n"
        body = f"Tu cÃ³digo OTP es: {code}\n\nVence en {settings.OTP_EXPIRE_MINUTES} minutos."

        msg = MIMEText(body, "plain", "utf-8")
        msg["Subject"] = subject
        msg["From"] = f"{settings.SMTP_FROM_NAME} <{settings.SMTP_FROM_EMAIL}>"
        msg["To"] = to_email

        with smtplib.SMTP(settings.SMTP_HOST, settings.SMTP_PORT) as server:
            server.starttls()
            server.login(settings.SMTP_USER, settings.SMTP_PASSWORD)
            server.sendmail(settings.SMTP_FROM_EMAIL, [to_email], msg.as_string())
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\gemini_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\pdf_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\s3_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\validation_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\conftest.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_admin_filters.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_auth.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_upload.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\dates.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\hashing.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\money.py
===============================
