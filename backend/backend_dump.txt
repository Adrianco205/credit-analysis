===============================
C:\Proyectos en desarrollo\credit-analysis\docker-compose.yml
===============================
services:
  db:
    image: postgres:16
    container_name: credit_analysis_db
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: credit_analysis_db
    ports:
      - "5434:5432"
    volumes:
      - credit_pgdata:/var/lib/postgresql/data
      - ./docker/postgres/init.sql:/docker-entrypoint-initdb.d/01-init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d credit_analysis_db"]
      interval: 5s
      timeout: 5s
      retries: 20

  backend:
    build: ./backend
    container_name: credit_analysis_api
    env_file: .env
    environment:
      - PYTHONPATH=/app
    depends_on:
      db:
        condition: service_healthy
    ports:
      - "8001:8000"
    volumes:
      - ./backend:/app
    command: >
      uvicorn app.main:app
      --host 0.0.0.0
      --port 8000
      --reload

  frontend:
    build: ./frontend
    container_name: credit_analysis_frontend
    ports:
      - "3000:3000"
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:8001/api/v1
    volumes:
      - ./frontend:/app
      - /app/node_modules
    depends_on:
      - backend

volumes:
  credit_pgdata:
===============================
C:\Proyectos en desarrollo\credit-analysis\.env
===============================
# ======================
# Base de Datos (Postgres)
# ======================
DB_USER=postgres
DB_PASSWORD=postgres
DB_HOST=db
DB_PORT=5432
DB_NAME=credit_analysis_db
DATABASE_URL=postgresql+psycopg2://postgres:postgres@db:5432/credit_analysis_db

# ======================
# Seguridad / JWT
# ======================
SECRET_KEY=una_llave_super_secreta_y_larga_123456
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=60

# ======================
# OTP / EMAIL
# ======================
OTP_EXPIRE_MINUTES=10
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=adrianangul267@gmail.com
SMTP_PASSWORD=zwhjbtldvzmkxkpf
SMTP_FROM_NAME=Credit Analysis
SMTP_FROM_EMAIL=adrianangul267@gmail.com

# (opcional)
APP_PUBLIC_NAME=Credit Analysis
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\.env.example
===============================
# ==========================================
# DATABASE CONFIGURATION
# ==========================================
DATABASE_URL=postgresql://user:password@localhost:5432/credit_analysis

# ==========================================
# SECURITY & JWT
# ==========================================
SECRET_KEY=your-super-secret-key-here-min-32-chars
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=60

# ==========================================
# OTP CONFIGURATION
# ==========================================
OTP_EXPIRE_MINUTES=10

# ==========================================
# SMTP / EMAIL CONFIGURATION
# ==========================================
# Para Gmail: Usar "App Password" (no la contraseña normal)
# Generar en: https://myaccount.google.com/apppasswords
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=tu-email@gmail.com
SMTP_PASSWORD=tu-app-password-aqui
SMTP_FROM_NAME=EcoFinanzas
SMTP_FROM_EMAIL=noreply@ecofinanzas.com

# ==========================================
# APPLICATION
# ==========================================
APP_PUBLIC_NAME=EcoFinanzas

# ==========================================
# GEMINI AI (para implementar)
# ==========================================
# GEMINI_API_KEY=tu-google-api-key-aqui

# ==========================================
# AWS S3 (para implementar)
# ==========================================
# AWS_ACCESS_KEY_ID=tu-access-key
# AWS_SECRET_ACCESS_KEY=tu-secret-key
# AWS_REGION=us-east-1
# S3_BUCKET_NAME=ecofinanzas-documents
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\alembic.ini
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\alembic\env.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\deps.py
===============================
import uuid
from typing import Callable
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from sqlalchemy.orm import Session
from sqlalchemy import select

from app.db.session import SessionLocal
from app.core.config import settings
from app.models.user import Usuario
from app.models.role import Role, UsuarioRole


security = HTTPBearer()


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> Usuario:
    """
    Decodifica el JWT del header Authorization, valida el usuario y retorna el Usuario activo.
    
    Raises:
        HTTPException 401: Si el token es inválido, expirado o el usuario no existe
        HTTPException 403: Si el usuario no está ACTIVE
    """
    token = credentials.credentials
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="No se pudo validar las credenciales",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id_str: str = payload.get("sub")
        if user_id_str is None:
            raise credentials_exception
        
        user_id = uuid.UUID(user_id_str)
    except (JWTError, ValueError):
        raise credentials_exception
    
    # Obtener usuario de la base de datos
    user = db.execute(
        select(Usuario).where(Usuario.id == user_id)
    ).scalar_one_or_none()
    
    if user is None:
        raise credentials_exception
    
    # Validar que el usuario esté activo
    if user.status != "ACTIVE":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Tu cuenta no está activa. Verifica tu correo para activarla."
        )
    
    return user


def require_role(*allowed_roles: str) -> Callable:
    """
    Dependencia que verifica si el usuario actual tiene uno de los roles permitidos.
    
    Args:
        *allowed_roles: Códigos de roles permitidos (e.g., "CLIENT", "ADMIN")
    
    Returns:
        Función de dependencia que valida el rol del usuario
    
    Example:
        @router.get("/admin/dashboard", dependencies=[Depends(require_role("ADMIN"))])
        async def admin_dashboard():
            ...
    """
    def role_checker(
        current_user: Usuario = Depends(get_current_user),
        db: Session = Depends(get_db)
    ) -> Usuario:
        # Obtener los roles del usuario
        user_roles = db.execute(
            select(Role.code)
            .join(UsuarioRole, UsuarioRole.role_id == Role.id)
            .where(UsuarioRole.user_id == current_user.id)
        ).scalars().all()
        
        # Verificar si tiene alguno de los roles permitidos
        if not any(role in allowed_roles for role in user_roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"No tienes permisos suficientes. Se requiere uno de estos roles: {', '.join(allowed_roles)}"
            )
        
        return current_user
    
    return role_checker
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\admin.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\analyses.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\auth.py
===============================
import secrets
import uuid
from datetime import datetime, timedelta, timezone

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from app.api.deps import get_db
from app.core.config import settings
from app.core.security import hash_password, verify_password, create_access_token
from app.models.user import Usuario
from app.models.otp import VerificacionOTP
from app.repositories.users_repo import UsersRepo
from app.repositories.otp_repo import OtpRepo
from app.services.email_otp_service import EmailOtpService
from app.schemas.auth import (
    RegisterRequest,
    RegisterResponse,
    VerifyOtpRequest,
    LoginRequest,
    TokenResponse,
)

router = APIRouter()



@router.post("/register", response_model=dict)
def register(
    payload: RegisterRequest, 
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    Registra un nuevo usuario y envía código OTP por email.
    
    - Si el usuario ya existe y está ACTIVE, devuelve error 409
    - Si existe pero está PENDING, reutiliza el registro y actualiza datos
    - El envío de email se ejecuta en background para no bloquear la respuesta
    """
    users = UsersRepo(db)
    
    try:
        # 1. Buscar si el usuario ya existe (por email o identificación)
        existing_user = users.get_by_email(str(payload.email)) or \
                        users.get_by_identificacion(payload.identificacion)

        if existing_user:
            # Si ya está activo, lanzamos el error de conflicto
            if existing_user.status == "ACTIVE":
                raise HTTPException(
                    status_code=status.HTTP_409_CONFLICT, 
                    detail="El usuario ya se encuentra registrado y activo."
                )
            
            # SI ESTÁ PENDING: Lo reutilizamos. Actualizamos sus datos por si cambió algo.
            user = existing_user
            user.nombres = payload.nombres
            user.primer_apellido = payload.primer_apellido
            user.segundo_apellido = payload.segundo_apellido
            user.password_hash = hash_password(payload.password)
            user.telefono = payload.telefono
            user.ciudad_id = payload.ciudad_id
            db.add(user)
            db.commit()
            db.refresh(user)
        else:
            # SI NO EXISTE: Creamos el nuevo registro
            user = Usuario(
                nombres=payload.nombres,
                primer_apellido=payload.primer_apellido,
                segundo_apellido=payload.segundo_apellido,
                tipo_identificacion=payload.tipo_identificacion,
                identificacion=payload.identificacion,
                email=str(payload.email),
                telefono=payload.telefono,
                genero=payload.genero,
                password_hash=hash_password(payload.password),
                ciudad_id=payload.ciudad_id,
                status="PENDING",
                email_verificado=False,
            )
            user = users.create_user(user)
            # Asignar rol por primera vez
            users.ensure_role_assignment(user.id, "CLIENT")

        # 2. Lógica de OTP (Se genera uno nuevo independientemente de si es nuevo o re-intento)
        code = f"{secrets.randbelow(1_000_000):06d}"
        expires = datetime.now(timezone.utc) + timedelta(minutes=settings.OTP_EXPIRE_MINUTES)

        otp_repo = OtpRepo(db)
        otp = VerificacionOTP(
            user_id=user.id,
            code_hash=hash_password(code),
            tipo="EMAIL",
            status="PENDING",
            expires_at=expires,
            used_at=None,
        )
        otp_repo.create(otp)

        # 3. Enviar email en background (no bloqueante)
        background_tasks.add_task(
            EmailOtpService.send_otp,
            to_email=str(payload.email),
            code=code
        )

        return RegisterResponse(
            user_id=str(user.id),
            status=user.status,
            message="Código de verificación enviado. Revisa tu correo para activar tu cuenta.",
        ).model_dump()
    
    except IntegrityError as e:
        db.rollback()
        # Manejar violación de constraints (email/identificación duplicada)
        if "email" in str(e.orig):
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="El correo electrónico ya está registrado"
            )
        elif "identificacion" in str(e.orig):
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="El número de identificación ya está registrado"
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Error al crear el usuario. Intenta nuevamente."
            )


@router.post("/verify-otp", response_model=dict)
def verify_otp(payload: VerifyOtpRequest, db: Session = Depends(get_db)):
    users = UsersRepo(db)
    otp_repo = OtpRepo(db)

    try:
        user_id = uuid.UUID(payload.user_id)
    except Exception:
        raise HTTPException(status_code=400, detail="ID de usuario no válido.")

    user = users.get_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="El usuario no existe.")

    # Obtenemos el último OTP pendiente
    otp = otp_repo.get_pending(user_id=user.id, tipo="EMAIL")
    if not otp:
        raise HTTPException(status_code=400, detail="No tienes códigos de verificación pendientes.")

    now = datetime.now(timezone.utc)

    # Verificar expiración
    if otp.expires_at and now > otp.expires_at:
        otp.status = "EXPIRED"
        db.add(otp)
        db.commit()
        raise HTTPException(status_code=400, detail="El código ha expirado. Regístrate de nuevo para recibir uno nuevo.")

    # Verificar validez del código
    if not verify_password(payload.code, otp.code_hash):
        raise HTTPException(status_code=400, detail="Código incorrecto.")

    # Marcar como verificado y activar usuario
    otp.status = "VERIFIED"
    otp.used_at = now
    db.add(otp)

    user.email_verificado = True
    user.status = "ACTIVE"
    db.add(user)
    
    db.commit()
    db.refresh(user)

    return {"message": "¡Cuenta activada con éxito! Ya puedes iniciar sesión.", "status": user.status}


@router.post("/login", response_model=dict)
def login(payload: LoginRequest, db: Session = Depends(get_db)):
    users = UsersRepo(db)
    user = users.get_by_identificacion(payload.identificacion)

    if not user or not user.password_hash or not verify_password(payload.password, user.password_hash):
        raise HTTPException(status_code=401, detail="Cédula o contraseña incorrectas.")

    if user.status != "ACTIVE":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Tu cuenta aún no está activa. Por favor verifica tu correo con el código OTP."
        )

    token = create_access_token(subject=str(user.id))
    return TokenResponse(access_token=token).model_dump()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\documents.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\locations.py
===============================
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy import or_
from typing import List

from app.api.deps import get_db
from app.models.location import Ciudad, Departamento
from pydantic import BaseModel

router = APIRouter()


class CiudadResponse(BaseModel):
    id: int
    nombre: str
    departamento: str

    class Config:
        from_attributes = True


@router.get("/cities", response_model=List[CiudadResponse])
def buscar_ciudades(
    q: str | None = Query(None, description="Buscar ciudades por nombre"),
    limit: int = Query(50, le=100),
    db: Session = Depends(get_db)
):
    """
    Busca ciudades de Colombia por nombre.
    Retorna máximo 50 resultados ordenados alfabéticamente.
    """
    query = db.query(Ciudad, Departamento).join(
        Departamento, Ciudad.departamento_id == Departamento.id
    )
    
    if q:
        search_term = f"%{q}%"
        query = query.filter(
            or_(
                Ciudad.nombre.ilike(search_term),
                Departamento.nombre.ilike(search_term)
            )
        )
    
    results = query.order_by(Ciudad.nombre).limit(limit).all()
    
    return [
        CiudadResponse(
            id=ciudad.id,
            nombre=ciudad.nombre,
            departamento=departamento.nombre
        )
        for ciudad, departamento in results
    ]
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\router.py
===============================
from fastapi import APIRouter
from app.api.v1.auth import router as auth_router
from app.api.v1.users import router as users_router
from app.api.v1.locations import router as locations_router

api_router = APIRouter()
api_router.include_router(auth_router, prefix="/auth", tags=["auth"])
api_router.include_router(users_router, prefix="/users", tags=["users"])
api_router.include_router(locations_router, prefix="/locations", tags=["locations"])
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\users.py
===============================
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.api.deps import get_db, get_current_user, require_role
from app.core.security import hash_password, verify_password
from app.models.user import Usuario
from app.schemas.user import UserProfileResponse, UpdatePasswordRequest

router = APIRouter()


@router.get("/me", response_model=UserProfileResponse)
def get_my_profile(current_user: Usuario = Depends(get_current_user)):
    """
    Obtiene el perfil del usuario autenticado.
    
    Retorna información básica: cédula, nombre completo, género, email.
    """
    return UserProfileResponse(
        id=str(current_user.id),
        identificacion=current_user.identificacion or "",
        nombres=current_user.nombres or "",
        primer_apellido=current_user.primer_apellido or "",
        segundo_apellido=current_user.segundo_apellido,
        genero=current_user.genero,
        email=current_user.email or "",
        telefono=current_user.telefono,
        status=current_user.status,
        email_verificado=current_user.email_verificado
    )


@router.patch("/me/password")
def update_password(
    payload: UpdatePasswordRequest,
    current_user: Usuario = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Actualiza la contraseña del usuario autenticado.
    
    Requiere proporcionar la contraseña actual para verificar identidad.
    """
    # Verificar contraseña actual
    if not current_user.password_hash or not verify_password(payload.current_password, current_user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="La contraseña actual es incorrecta"
        )
    
    # Validar que la nueva contraseña sea diferente
    if payload.current_password == payload.new_password:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="La nueva contraseña debe ser diferente a la actual"
        )
    
    # Actualizar contraseña
    current_user.password_hash = hash_password(payload.new_password)
    db.add(current_user)
    db.commit()
    
    return {
        "message": "Contraseña actualizada exitosamente"
    }
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\config.py
===============================
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str

    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    OTP_EXPIRE_MINUTES: int = 10

    SMTP_HOST: str
    SMTP_PORT: int = 587
    SMTP_USER: str
    SMTP_PASSWORD: str
    SMTP_FROM_NAME: str = "Credit Analysis"
    SMTP_FROM_EMAIL: str

    APP_PUBLIC_NAME: str = "Credit Analysis"

    class Config:
        env_file = ".env"


settings = Settings()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\exceptions.py
===============================
"""
Exception handlers y middleware para manejo global de errores.
Captura errores de base de datos, validación y excepciones no controladas.
"""
import logging
from typing import Union
from fastapi import Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import IntegrityError, OperationalError, DataError
from pydantic import ValidationError

logger = logging.getLogger(__name__)


class ErrorResponse:
    """Estructura estandarizada para respuestas de error"""
    
    @staticmethod
    def format(
        error_type: str,
        message: str,
        detail: Union[str, dict, list, None] = None,
        status_code: int = 500
    ) -> dict:
        """
        Crea una respuesta de error estandarizada.
        
        Args:
            error_type: Tipo de error (validation, database, server, etc.)
            message: Mensaje principal del error
            detail: Detalles adicionales opcionales
            status_code: Código HTTP del error
            
        Returns:
            Dict con estructura de error estandarizada
        """
        response = {
            "error": error_type,
            "message": message,
            "status_code": status_code
        }
        
        if detail:
            response["detail"] = detail
        
        return response


async def integrity_error_handler(request: Request, exc: IntegrityError) -> JSONResponse:
    """
    Maneja errores de integridad de base de datos (constraints, duplicados).
    
    Args:
        request: Request de FastAPI
        exc: Excepción de IntegrityError
        
    Returns:
        JSONResponse con error formateado
    """
    logger.warning(f"IntegrityError en {request.url.path}: {str(exc.orig)}")
    
    error_msg = str(exc.orig).lower()
    
    # Detectar tipo de violación de constraint
    if "unique" in error_msg or "duplicate" in error_msg:
        if "email" in error_msg:
            message = "El correo electrónico ya está registrado"
        elif "identificacion" in error_msg:
            message = "El número de identificación ya está registrado"
        else:
            message = "El valor ingresado ya existe en el sistema"
        
        return JSONResponse(
            status_code=status.HTTP_409_CONFLICT,
            content=ErrorResponse.format(
                error_type="duplicate_entry",
                message=message,
                status_code=status.HTTP_409_CONFLICT
            )
        )
    
    elif "foreign key" in error_msg:
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content=ErrorResponse.format(
                error_type="invalid_reference",
                message="Referencia a registro inexistente",
                detail="Uno de los valores proporcionados no existe en el sistema",
                status_code=status.HTTP_400_BAD_REQUEST
            )
        )
    
    elif "not null" in error_msg:
        return JSONResponse(
            status_code=status.HTTP_400_BAD_REQUEST,
            content=ErrorResponse.format(
                error_type="missing_required_field",
                message="Falta un campo obligatorio",
                status_code=status.HTTP_400_BAD_REQUEST
            )
        )
    
    # Error genérico de integridad
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content=ErrorResponse.format(
            error_type="database_integrity_error",
            message="Error de validación en la base de datos",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    )


async def operational_error_handler(request: Request, exc: OperationalError) -> JSONResponse:
    """
    Maneja errores operacionales de base de datos (conexión, timeout, etc.).
    
    Args:
        request: Request de FastAPI
        exc: Excepción de OperationalError
        
    Returns:
        JSONResponse con error formateado
    """
    logger.error(f"OperationalError en {request.url.path}: {str(exc)}")
    
    return JSONResponse(
        status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
        content=ErrorResponse.format(
            error_type="database_unavailable",
            message="Error de conexión con la base de datos. Intenta nuevamente en unos momentos.",
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE
        )
    )


async def data_error_handler(request: Request, exc: DataError) -> JSONResponse:
    """
    Maneja errores de datos inválidos en base de datos.
    
    Args:
        request: Request de FastAPI
        exc: Excepción de DataError
        
    Returns:
        JSONResponse con error formateado
    """
    logger.warning(f"DataError en {request.url.path}: {str(exc.orig)}")
    
    return JSONResponse(
        status_code=status.HTTP_400_BAD_REQUEST,
        content=ErrorResponse.format(
            error_type="invalid_data_format",
            message="Formato de datos inválido",
            detail="Uno o más campos tienen un formato incorrecto",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    )


async def validation_error_handler(request: Request, exc: RequestValidationError) -> JSONResponse:
    """
    Maneja errores de validación de Pydantic.
    
    Args:
        request: Request de FastAPI
        exc: Excepción de RequestValidationError
        
    Returns:
        JSONResponse con errores de validación formateados
    """
    logger.info(f"ValidationError en {request.url.path}: {exc.errors()}")
    
    # Formatear errores de validación de forma más amigable
    formatted_errors = []
    for error in exc.errors():
        field = " -> ".join(str(loc) for loc in error["loc"][1:])  # Omitir 'body'
        formatted_errors.append({
            "field": field,
            "message": error["msg"],
            "type": error["type"]
        })
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=ErrorResponse.format(
            error_type="validation_error",
            message="Error de validación en los datos enviados",
            detail=formatted_errors,
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY
        )
    )


async def generic_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """
    Maneja excepciones no controladas.
    
    Args:
        request: Request de FastAPI
        exc: Excepción genérica
        
    Returns:
        JSONResponse con error genérico
    """
    logger.error(f"Unhandled exception en {request.url.path}: {type(exc).__name__} - {str(exc)}", exc_info=True)
    
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content=ErrorResponse.format(
            error_type="internal_server_error",
            message="Error interno del servidor",
            detail="Ha ocurrido un error inesperado. El equipo técnico ha sido notificado.",
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR
        )
    )
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\logging.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\security.py
===============================
from datetime import datetime, timedelta, timezone
from jose import jwt
from passlib.context import CryptContext
from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


def create_access_token(subject: str) -> str:
    expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    payload = {"sub": subject, "exp": expire}
    return jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\db\base.py
===============================
from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    pass
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\db\migrations.md
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\db\session.py
===============================
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\main.py
===============================
from fastapi import FastAPI
from fastapi.exceptions import RequestValidationError
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from apscheduler.schedulers.background import BackgroundScheduler
from sqlalchemy.exc import IntegrityError, OperationalError, DataError

from app.api.v1.router import api_router
from app.services.cleanup_service import cleanup_expired_pending_users
from app.core.exceptions import (
    integrity_error_handler,
    operational_error_handler,
    data_error_handler,
    validation_error_handler,
    generic_exception_handler
)


@asynccontextmanager
async def lifespan(app: FastAPI):
    # --- Al iniciar la aplicación ---
    scheduler = BackgroundScheduler()
    # Programamos para que revise la DB cada 10 minutos (puedes ajustar este intervalo)
    scheduler.add_job(cleanup_expired_pending_users, 'interval', minutes=10)
    scheduler.start()
    
    yield # Aquí la app funciona normalmente
    
    # --- Al apagar la aplicación ---
    scheduler.shutdown()


app = FastAPI(
    title="EcoFinanzas Credit Analysis API",
    description="API para análisis de créditos hipotecarios con IA",
    version="1.0.0",
    lifespan=lifespan
)

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # En producción, especificar dominios permitidos
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Registrar exception handlers globales
app.add_exception_handler(IntegrityError, integrity_error_handler)
app.add_exception_handler(OperationalError, operational_error_handler)
app.add_exception_handler(DataError, data_error_handler)
app.add_exception_handler(RequestValidationError, validation_error_handler)
app.add_exception_handler(Exception, generic_exception_handler)

# Registrar routers
app.include_router(api_router, prefix="/api/v1")
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\__init__.py
===============================
from app.models.user import Usuario
from app.models.role import Role, UsuarioRole
from app.models.otp import VerificacionOTP
from app.models.location import Departamento, Ciudad  # <-- AGREGA ESTO
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\analisis.py
===============================
import uuid
from datetime import date, datetime
from decimal import Decimal
from sqlalchemy import String, Integer, Numeric, Boolean, Date, DateTime, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class AnalisisHipotecario(Base):
    """
    Modelo para análisis de crédito hipotecario.
    Almacena datos extraídos del PDF y proporcionados por el usuario.
    """
    __tablename__ = "analisis_hipotecario"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        server_default=text("gen_random_uuid()")
    )
    documento_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("documentos_s3.id", ondelete="CASCADE"),
        nullable=False
    )
    
    # Datos proporcionados por el usuario
    ingresos_mensuales: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    capacidad_pago_max: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    tipo_contrato_laboral: Mapped[str | None] = mapped_column(String(80))
    
    # Datos básicos del crédito (extraídos del PDF)
    numero_credito: Mapped[str | None] = mapped_column(String(50))
    sistema_amortizacion: Mapped[str | None] = mapped_column(String(20))  # UVR, PESOS, etc.
    valor_prestado_inicial: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    fecha_desembolso: Mapped[date | None] = mapped_column(Date)
    
    # Estado del crédito
    cuotas_pactadas: Mapped[int | None] = mapped_column(Integer)
    cuotas_pagadas: Mapped[int | None] = mapped_column(Integer)
    cuotas_pendientes: Mapped[int | None] = mapped_column(Integer)
    
    # Montos actuales
    valor_cuota_actual: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    beneficio_frech_mensual: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    saldo_capital_hoy: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    
    # Ajustes y cargos
    ajuste_inflacion_pesos: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    intereses_mes_actual: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    seguros_totales: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    
    # Validaciones
    es_analisis_real: Mapped[bool] = mapped_column(Boolean, server_default=text("true"))
    validado_por_sistema: Mapped[bool] = mapped_column(Boolean, server_default=text("false"))
    
    # Datos manuales ingresados por el usuario (JSON flexible)
    datos_manuales_json: Mapped[dict | None] = mapped_column(JSONB, nullable=True)
    
    updated_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\auditoria.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\banco.py
===============================
from sqlalchemy import String, Integer
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class Banco(Base):
    """Modelo para entidades bancarias"""
    __tablename__ = "bancos"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    nombre: Mapped[str | None] = mapped_column(String(100), unique=True)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\documento.py
===============================
import uuid
from datetime import datetime
from sqlalchemy import String, BigInteger, Boolean, DateTime, ForeignKey, Text, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class DocumentoS3(Base):
    """
    Modelo para documentos PDF almacenados en S3 (o localmente).
    Almacena metadata del archivo y su estado de procesamiento.
    """
    __tablename__ = "documentos_s3"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        server_default=text("gen_random_uuid()")
    )
    usuario_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        ForeignKey("usuarios.id", ondelete="CASCADE"), 
        nullable=False
    )
    banco_id: Mapped[int | None] = mapped_column(
        ForeignKey("bancos.id", ondelete="SET NULL"),
        nullable=True
    )
    
    # Metadata del archivo
    s3_key: Mapped[str | None] = mapped_column(Text, nullable=True)  # Ruta en S3 o filesystem
    original_filename: Mapped[str | None] = mapped_column(String(255))
    file_size: Mapped[int | None] = mapped_column(BigInteger)
    mime_type: Mapped[str | None] = mapped_column(String(50))
    
    # Seguridad y validación
    pdf_encrypted: Mapped[bool] = mapped_column(Boolean, server_default=text("false"))
    checksum_sha256: Mapped[str | None] = mapped_column(String(64))  # Hash del archivo
    
    # Estado del procesamiento
    status: Mapped[str] = mapped_column(
        String(20), 
        server_default=text("'UPLOADED'")
    )  # UPLOADED, PROCESSING, COMPLETED, FAILED
    
    created_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("now()")
    )
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\location.py
===============================
from sqlalchemy import String, ForeignKey, Integer
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base

class Departamento(Base):
    __tablename__ = "departamentos"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    nombre: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)

class Ciudad(Base):
    __tablename__ = "ciudades"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    departamento_id: Mapped[int] = mapped_column(ForeignKey("departamentos.id"), nullable=False)
    nombre: Mapped[str] = mapped_column(String(100), nullable=False)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\opcion_abono.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\otp.py
===============================
import uuid
from sqlalchemy import String, DateTime, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class VerificacionOTP(Base):
    __tablename__ = "verificaciones_otp"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, server_default=text("gen_random_uuid()"))
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("usuarios.id", ondelete="CASCADE"), nullable=False)

    code_hash: Mapped[str | None] = mapped_column(String(255))
    tipo: Mapped[str | None] = mapped_column(String(20))  # EMAIL
    status: Mapped[str] = mapped_column(String(20), server_default=text("'PENDING'"))  # PENDING/VERIFIED/EXPIRED

    expires_at: Mapped[str | None] = mapped_column(DateTime(timezone=True))
    used_at: Mapped[str | None] = mapped_column(DateTime(timezone=True))
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\propuesta.py
===============================
import uuid
from decimal import Decimal
from sqlalchemy import String, Integer, Numeric, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class PropuestaAhorro(Base):
    """
    Modelo para propuestas de ahorro (nuevas oportunidades).
    Cada análisis puede tener múltiples opciones de abono adicional.
    """
    __tablename__ = "propuestas_ahorro"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), 
        primary_key=True, 
        server_default=text("gen_random_uuid()")
    )
    analisis_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("analisis_hipotecario.id", ondelete="CASCADE"),
        nullable=False
    )
    
    # Identificador de la opción (1ra, 2da, 3ra elección)
    numero_opcion: Mapped[int] = mapped_column(Integer)  # 1, 2, 3, etc.
    
    # Abono adicional propuesto
    abono_adicional: Mapped[Decimal] = mapped_column(Numeric(15, 2))
    
    # Resultados calculados
    cuotas_reducidas: Mapped[int | None] = mapped_column(Integer)
    tiempo_ahorrado_meses: Mapped[int | None] = mapped_column(Integer)
    valor_ahorrado_intereses: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    nuevo_valor_cuota: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    total_por_pagar_aprox: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    
    # Honorarios y requisitos
    honorarios_calculados: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    ingreso_minimo_requerido: Mapped[Decimal | None] = mapped_column(Numeric(15, 2))
    
    # Metadata
    origen: Mapped[str] = mapped_column(String(20), server_default=text("'USER'"))  # USER, ADMIN
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\role.py
===============================
import uuid
from sqlalchemy import String, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class Role(Base):
    __tablename__ = "roles"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    code: Mapped[str | None] = mapped_column(String(30), unique=True)
    name: Mapped[str | None] = mapped_column(String(80))


class UsuarioRole(Base):
    __tablename__ = "usuario_roles"

    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("usuarios.id", ondelete="CASCADE"), primary_key=True)
    role_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("roles.id", ondelete="CASCADE"), primary_key=True)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\user.py
===============================
import uuid
from sqlalchemy import String, Boolean, DateTime, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class Usuario(Base):
    __tablename__ = "usuarios"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, server_default=text("gen_random_uuid()"))
    nombres: Mapped[str | None] = mapped_column(String(150))
    primer_apellido: Mapped[str | None] = mapped_column(String(80))
    segundo_apellido: Mapped[str | None] = mapped_column(String(80))
    tipo_identificacion: Mapped[str | None] = mapped_column(String(10))
    identificacion: Mapped[str | None] = mapped_column(String(30), unique=True)
    email: Mapped[str | None] = mapped_column(String(255), unique=True)
    telefono: Mapped[str | None] = mapped_column(String(30))
    genero: Mapped[str | None] = mapped_column(String(20))
    password_hash: Mapped[str | None] = mapped_column(String(255))

    ciudad_id: Mapped[int | None] = mapped_column(ForeignKey("ciudades.id", ondelete="SET NULL"), nullable=True)

    status: Mapped[str] = mapped_column(String(20), server_default=text("'PENDING'"))
    email_verificado: Mapped[bool] = mapped_column(Boolean, server_default=text("false"))
    created_at: Mapped[str | None] = mapped_column(DateTime(timezone=True), server_default=text("now()"))
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\admin_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\analyses_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\documents_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\otp_repo.py
===============================
from sqlalchemy.orm import Session
from sqlalchemy import select
from app.models.otp import VerificacionOTP


class OtpRepo:
    def __init__(self, db: Session):
        self.db = db

    def create(self, otp: VerificacionOTP) -> VerificacionOTP:
        self.db.add(otp)
        self.db.commit()
        self.db.refresh(otp)
        return otp

    def get_pending(self, user_id, tipo: str) -> VerificacionOTP | None:
        return self.db.execute(
            select(VerificacionOTP)
            .where(
                VerificacionOTP.user_id == user_id,
                VerificacionOTP.tipo == tipo,
                VerificacionOTP.status == "PENDING",
            )
            .order_by(VerificacionOTP.expires_at.desc())
        ).scalar_one_or_none()

    def save(self, otp: VerificacionOTP):
        self.db.add(otp)
        self.db.commit()
        self.db.refresh(otp)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\users_repo.py
===============================
import uuid  # <--- ESTA ES LA LÍNEA QUE FALTABA
from sqlalchemy.orm import Session
from sqlalchemy import select
from app.models.user import Usuario
from app.models.role import Role, UsuarioRole

class UsersRepo:
    def __init__(self, db: Session):
        self.db = db

    def get_by_email(self, email: str) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.email == email)).scalar_one_or_none()

    def get_by_identificacion(self, identificacion: str) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.identificacion == identificacion)).scalar_one_or_none()

    def get_by_id(self, user_id) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.id == user_id)).scalar_one_or_none()

    def create_user(self, user: Usuario) -> Usuario:
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user

    def ensure_role_assignment(self, user_id, role_code: str):
        role = self.db.execute(select(Role).where(Role.code == role_code)).scalar_one_or_none()
        if not role:
            raise ValueError(f"Role {role_code} no existe (seed roles).")

        exists = self.db.execute(
            select(UsuarioRole).where(UsuarioRole.user_id == user_id, UsuarioRole.role_id == role.id)
        ).scalar_one_or_none()

        if not exists:
            self.db.add(UsuarioRole(user_id=user_id, role_id=role.id))
            self.db.commit()

    # Función añadida para el flujo de re-intento de registro
    def update_pending_user(self, user_id: uuid.UUID, **kwargs) -> Usuario:
        user = self.get_by_id(user_id)
        if user and user.status == "PENDING":
            for key, value in kwargs.items():
                setattr(user, key, value)
            self.db.commit()
            self.db.refresh(user)
        return user
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\analisis.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\auth.py
===============================
from pydantic import BaseModel, EmailStr, Field


class RegisterRequest(BaseModel):
    nombres: str = Field(min_length=1, max_length=150)
    primer_apellido: str = Field(min_length=1, max_length=80)
    segundo_apellido: str | None = Field(default=None, max_length=80)

    tipo_identificacion: str = Field(min_length=1, max_length=10)
    identificacion: str = Field(min_length=3, max_length=30)

    email: EmailStr
    telefono: str | None = Field(default=None, max_length=30)
    genero: str | None = Field(default=None, max_length=20)

    password: str = Field(min_length=8, max_length=72)

    ciudad_id: int | None = None


class RegisterResponse(BaseModel):
    user_id: str
    status: str
    message: str


class VerifyOtpRequest(BaseModel):
    user_id: str
    code: str = Field(min_length=4, max_length=12)


class LoginRequest(BaseModel):
    identificacion: str
    password: str


class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\documentos.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\propuestas.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\user.py
===============================
from pydantic import BaseModel, Field


class UserProfileResponse(BaseModel):
    """Schema para la respuesta del perfil de usuario"""
    id: str
    identificacion: str
    nombres: str
    primer_apellido: str
    segundo_apellido: str | None
    genero: str | None
    email: str
    telefono: str | None
    status: str
    email_verificado: bool


class UpdatePasswordRequest(BaseModel):
    """Schema para actualizar contraseña"""
    current_password: str = Field(min_length=1, description="Contraseña actual")
    new_password: str = Field(min_length=8, max_length=72, description="Nueva contraseña")
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\calc_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\cleanup_service.py
===============================
from datetime import datetime, timedelta, timezone
from sqlalchemy import delete
from app.db.session import SessionLocal
from app.models.user import Usuario
import logging

# Configuración básica de logs para ver la limpieza en la consola de Docker
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def cleanup_expired_pending_users():
    """
    Elimina usuarios en estado 'PENDING' que lleven más de 40 minutos sin activar.
    """
    db = SessionLocal()
    try:
        # Definimos el tiempo límite: ahora menos 40 minutos
        # Usamos timezone.utc porque tus modelos usan DateTime(timezone=True)
        threshold_time = datetime.now(timezone.utc) - timedelta(minutes=40)
        
        # Ejecutamos la eliminación
        # El ON DELETE CASCADE de la DB limpiará las tablas: 
        # usuario_roles, verificaciones_otp, etc.
        stmt = delete(Usuario).where(
            Usuario.status == "PENDING",
            Usuario.created_at <= threshold_time
        )
        
        result = db.execute(stmt)
        db.commit()
        
        if result.rowcount > 0:
            logger.info(f"🧹 [CLEANUP] Se eliminaron {result.rowcount} registros PENDING expirados (>40 min).")
            
    except Exception as e:
        logger.error(f"❌ [CLEANUP ERROR] Falló la limpieza automática: {e}")
        db.rollback()
    finally:
        db.close()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\email_otp_service.py
===============================
import smtplib
import logging
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from app.core.config import settings

logger = logging.getLogger(__name__)


class EmailOtpService:
    """
    Servicio para envío de códigos OTP por email.
    Diseñado para ser ejecutado en BackgroundTasks de FastAPI.
    """
    
    @staticmethod
    def send_otp(to_email: str, code: str) -> bool:
        """
        Envía un código OTP por correo electrónico.
        
        Args:
            to_email: Dirección de correo destino
            code: Código OTP a enviar
            
        Returns:
            bool: True si se envió exitosamente, False en caso contrario
        """
        try:
            # 1. Crear el contenedor del mensaje
            msg = MIMEMultipart()
            msg["From"] = f"{settings.SMTP_FROM_NAME} <{settings.SMTP_FROM_EMAIL}>"
            msg["To"] = to_email
            msg["Subject"] = f"Código de Verificación - {settings.APP_PUBLIC_NAME}"

            # 2. Cuerpo del mensaje con formato profesional
            body = f"""
Hola,

Tu código de verificación para activar tu cuenta de {settings.APP_PUBLIC_NAME} es:

    {code}

Este código expirará en {settings.OTP_EXPIRE_MINUTES} minutos.
Si no solicitaste este registro, puedes ignorar este correo.

---
Equipo de {settings.APP_PUBLIC_NAME}
            """
            msg.attach(MIMEText(body, "plain"))

            # 3. Conexión al servidor SMTP
            with smtplib.SMTP(settings.SMTP_HOST, settings.SMTP_PORT, timeout=10) as server:
                server.set_debuglevel(0)
                server.starttls()  # Inicia cifrado TLS
                
                # 4. Autenticación
                server.login(settings.SMTP_USER, settings.SMTP_PASSWORD)
                
                # 5. Envío
                server.send_message(msg)
                
            logger.info(f"✅ Email OTP enviado exitosamente a {to_email}")
            return True

        except smtplib.SMTPAuthenticationError as e:
            logger.error(f"❌ Error de autenticación SMTP: {str(e)}")
            return False
        except smtplib.SMTPException as e:
            logger.error(f"❌ Error SMTP al enviar email a {to_email}: {str(e)}")
            return False
        except Exception as e:
            logger.error(f"❌ Error inesperado al enviar email a {to_email}: {str(e)}")
            return False
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\gemini_service.py
===============================
import logging
from typing import Dict, Any

logger = logging.getLogger(__name__)


class GeminiService:
    """
    Servicio para interacción con Gemini 1.5 Pro/Flash.
    Procesa PDFs de análisis de crédito y extrae datos estructurados en JSON.
    """
    
    def __init__(self, api_key: str | None = None):
        """
        Inicializa el servicio de Gemini.
        
        Args:
            api_key: API key de Google Generative AI
        """
        self.api_key = api_key
        # TODO: Inicializar cliente de Gemini cuando se agregue la librería
        # import google.generativeai as genai
        # genai.configure(api_key=self.api_key)
        # self.model = genai.GenerativeModel('gemini-1.5-pro')
    
    async def extract_credit_analysis(
        self, 
        pdf_content: bytes,
        context: Dict[str, Any] | None = None
    ) -> Dict[str, Any]:
        """
        Extrae datos estructurados de un PDF de análisis de crédito usando Gemini.
        
        Args:
            pdf_content: Contenido binario del PDF
            context: Contexto adicional (banco, usuario, etc.)
            
        Returns:
            Dict con datos extraídos en formato JSON
            
        Ejemplo de respuesta esperada:
        {
            "numero_credito": "123456789",
            "valor_prestado_inicial": 150000000.00,
            "cuotas_pactadas": 180,
            "cuotas_pagadas": 24,
            "saldo_capital_hoy": 142000000.00,
            "valor_cuota_actual": 1200000.00,
            "beneficio_frech_mensual": 200000.00,
            "sistema_amortizacion": "UVR",
            "nombre_titular": "Juan Pérez García",
            ...
        }
        """
        logger.info("Iniciando extracción de datos con Gemini")
        
        # TODO: Implementar llamada a Gemini API
        # Prompt example:
        # prompt = '''
        # Analiza el siguiente documento de análisis de crédito hipotecario y extrae 
        # la siguiente información en formato JSON:
        # - numero_credito
        # - valor_prestado_inicial
        # - cuotas_pactadas, cuotas_pagadas, cuotas_pendientes
        # - saldo_capital_hoy
        # - valor_cuota_actual
        # - beneficio_frech_mensual (si aplica)
        # - sistema_amortizacion (UVR, PESOS, etc.)
        # - nombre_titular
        # - fecha_desembolso
        # - intereses_mes_actual
        # - seguros_totales
        # '''
        
        # Por ahora retornamos estructura vacía
        return {
            "extraction_status": "pending",
            "message": "Gemini API integration pending",
            "data": {}
        }
    
    async def validate_document_authenticity(self, pdf_content: bytes) -> Dict[str, Any]:
        """
        Valida que el documento sea un análisis de crédito real usando Gemini.
        
        Args:
            pdf_content: Contenido binario del PDF
            
        Returns:
            Dict con resultado de validación:
            {
                "is_valid": bool,
                "confidence": float,
                "reason": str
            }
        """
        logger.info("Validando autenticidad del documento con Gemini")
        
        # TODO: Implementar validación con Gemini
        # Prompt: "¿Este documento es un análisis de crédito hipotecario real? 
        # Responde en JSON con is_valid, confidence y reason"
        
        return {
            "is_valid": True,
            "confidence": 0.0,
            "reason": "Validación pendiente - Gemini API no integrada"
        }
    
    async def compare_names(
        self, 
        pdf_name: str, 
        user_name: str
    ) -> Dict[str, Any]:
        """
        Compara el nombre en el PDF con el nombre del usuario usando matching inteligente.
        
        Args:
            pdf_name: Nombre extraído del PDF
            user_name: Nombre del usuario autenticado
            
        Returns:
            Dict con resultado de comparación:
            {
                "match": bool,
                "similarity": float,
                "normalized_pdf_name": str,
                "normalized_user_name": str
            }
        """
        # TODO: Implementar con rapidfuzz o Gemini para matching tolerante
        # from rapidfuzz import fuzz
        # similarity = fuzz.ratio(pdf_name.lower(), user_name.lower()) / 100.0
        
        return {
            "match": False,
            "similarity": 0.0,
            "normalized_pdf_name": pdf_name,
            "normalized_user_name": user_name,
            "message": "Name matching pending implementation"
        }
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\pdf_service.py
===============================
import hashlib
import logging
from pathlib import Path
from typing import BinaryIO, Tuple
import PyPDF2

logger = logging.getLogger(__name__)


class PdfService:
    """
    Servicio para manejo de archivos PDF.
    Incluye detección de encriptación y preparación para extracción con IA.
    """
    
    @staticmethod
    def is_pdf_encrypted(file_stream: BinaryIO) -> bool:
        """
        Detecta si un PDF está protegido con contraseña.
        
        Args:
            file_stream: Stream del archivo PDF
            
        Returns:
            bool: True si el PDF está encriptado, False en caso contrario
        """
        try:
            # Resetear el cursor al inicio
            file_stream.seek(0)
            
            # Intentar leer el PDF
            reader = PyPDF2.PdfReader(file_stream)
            
            # PyPDF2 detecta automáticamente si está encriptado
            is_encrypted = reader.is_encrypted
            
            # Resetear cursor para uso posterior
            file_stream.seek(0)
            
            return is_encrypted
            
        except Exception as e:
            logger.error(f"Error al verificar encriptación del PDF: {str(e)}")
            file_stream.seek(0)
            return False
    
    @staticmethod
    def decrypt_pdf(file_stream: BinaryIO, password: str) -> Tuple[bool, str]:
        """
        Intenta desencriptar un PDF con la contraseña proporcionada.
        
        Args:
            file_stream: Stream del archivo PDF
            password: Contraseña para desencriptar
            
        Returns:
            Tuple[bool, str]: (éxito, mensaje)
        """
        try:
            file_stream.seek(0)
            reader = PyPDF2.PdfReader(file_stream)
            
            if not reader.is_encrypted:
                return True, "El PDF no está encriptado"
            
            # Intentar desencriptar
            if reader.decrypt(password):
                # Verificar que realmente se puede leer
                try:
                    _ = len(reader.pages)
                    file_stream.seek(0)
                    return True, "PDF desencriptado exitosamente"
                except Exception as e:
                    logger.warning(f"PDF desencriptado pero no se puede leer: {str(e)}")
                    file_stream.seek(0)
                    return False, "Contraseña incorrecta o PDF corrupto"
            else:
                file_stream.seek(0)
                return False, "Contraseña incorrecta"
                
        except Exception as e:
            logger.error(f"Error al desencriptar PDF: {str(e)}")
            file_stream.seek(0)
            return False, f"Error al procesar el PDF: {str(e)}"
    
    @staticmethod
    def calculate_checksum(file_stream: BinaryIO) -> str:
        """
        Calcula el hash SHA-256 del archivo para verificar integridad.
        
        Args:
            file_stream: Stream del archivo
            
        Returns:
            str: Hash SHA-256 hexadecimal
        """
        file_stream.seek(0)
        sha256_hash = hashlib.sha256()
        
        # Leer en chunks para archivos grandes
        for chunk in iter(lambda: file_stream.read(8192), b""):
            sha256_hash.update(chunk)
        
        file_stream.seek(0)
        return sha256_hash.hexdigest()
    
    @staticmethod
    def extract_text_basic(file_stream: BinaryIO, password: str | None = None) -> str:
        """
        Extrae texto básico del PDF usando PyPDF2.
        Útil para validación rápida antes de enviar a Gemini.
        
        Args:
            file_stream: Stream del archivo PDF
            password: Contraseña si el PDF está protegido
            
        Returns:
            str: Texto extraído del PDF
        """
        try:
            file_stream.seek(0)
            reader = PyPDF2.PdfReader(file_stream)
            
            # Si está encriptado, intentar desencriptar
            if reader.is_encrypted and password:
                reader.decrypt(password)
            
            # Extraer texto de todas las páginas
            text_parts = []
            for page in reader.pages:
                text = page.extract_text()
                if text:
                    text_parts.append(text)
            
            file_stream.seek(0)
            return "\n".join(text_parts)
            
        except Exception as e:
            logger.error(f"Error al extraer texto del PDF: {str(e)}")
            file_stream.seek(0)
            return ""
    
    @staticmethod
    def validate_credit_analysis_keywords(text: str) -> Tuple[bool, float]:
        """
        Valida que el texto contenga palabras clave de un análisis de crédito.
        
        Args:
            text: Texto extraído del PDF
            
        Returns:
            Tuple[bool, float]: (es válido, score_confianza)
        """
        # Palabras clave que debe contener un análisis de crédito
        keywords = [
            "crédito", "credito", "préstamo", "prestamo", "cuota",
            "capital", "interés", "interes", "saldo", "desembolso",
            "amortización", "amortizacion", "banco", "hipotecario"
        ]
        
        text_lower = text.lower()
        matches = sum(1 for keyword in keywords if keyword in text_lower)
        
        # Score de confianza basado en matches
        confidence_score = min(matches / len(keywords), 1.0)
        
        # Se considera válido si tiene al menos 30% de las keywords
        is_valid = confidence_score >= 0.3
        
        return is_valid, confidence_score
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\s3_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\validation_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\conftest.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_admin_filters.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_auth.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_upload.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\dates.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\hashing.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\money.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\Dockerfile
===============================
FROM python:3.12-slim

WORKDIR /app

# deps sistema (psycopg2)
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc libpq-dev \
  && rm -rf /var/lib/apt/lists/*

COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

COPY . /app

EXPOSE 8000
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\pyproject.toml
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\README.md
===============================
# 🏦 EcoFinanzas Backend - API de Análisis de Crédito

Backend refactorizado con arquitectura senior para análisis de créditos hipotecarios con IA.

## 🚀 Stack Tecnológico

- **Framework**: FastAPI 0.115.0
- **ORM**: SQLAlchemy 2.0.34
- **Database**: PostgreSQL 16+
- **Authentication**: JWT (python-jose)
- **Security**: bcrypt hashing
- **IA**: Gemini 1.5 Pro/Flash (pendiente integración)
- **Background Jobs**: APScheduler
- **PDF Processing**: PyPDF2

## 📋 Requisitos Previos

- Python 3.11+
- PostgreSQL 16+
- pip (gestor de paquetes)

## 🔧 Instalación

### 1. Clonar y navegar al directorio

```bash
cd backend/
```

### 2. Crear entorno virtual

```bash
python -m venv venv

# Windows
venv\Scripts\activate

# Linux/Mac
source venv/bin/activate
```

### 3. Instalar dependencias

```bash
pip install -r requirements.txt
```

### 4. Configurar variables de entorno

```bash
# Copiar el archivo de ejemplo
cp .env.example .env

# Editar .env con tus credenciales reales
notepad .env  # Windows
nano .env     # Linux/Mac
```

**Variables obligatorias:**
- `DATABASE_URL`: Conexión a PostgreSQL
- `SECRET_KEY`: Mínimo 32 caracteres aleatorios
- `SMTP_*`: Credenciales de email (Gmail App Password recomendado)

### 5. Inicializar base de datos

```bash
# Asegúrate que PostgreSQL esté corriendo
# Ejecutar desde la raíz del proyecto con Docker:
docker-compose up -d postgres

# O manualmente:
# createdb credit_analysis
# psql -d credit_analysis -f docker/postgres/init.sql
```

### 6. Ejecutar el servidor

```bash
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

La API estará disponible en: `http://localhost:8000`

## 📚 Documentación de la API

- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

## 🔐 Endpoints Principales

### Auth
- `POST /api/v1/auth/register` - Registro de usuario
- `POST /api/v1/auth/verify-otp` - Verificar código OTP
- `POST /api/v1/auth/login` - Iniciar sesión

### Users (requiere autenticación)
- `GET /api/v1/users/me` - Ver perfil
- `PATCH /api/v1/users/me/password` - Cambiar contraseña

## 🏗️ Arquitectura

```
backend/
├── app/
│   ├── main.py                    # Punto de entrada, exception handlers
│   ├── api/
│   │   ├── deps.py               # Dependencias (auth, roles)
│   │   └── v1/
│   │       ├── router.py         # Router principal
│   │       ├── auth.py           # Endpoints de autenticación
│   │       └── users.py          # Endpoints de usuarios
│   ├── core/
│   │   ├── config.py             # Configuración (pydantic-settings)
│   │   ├── security.py           # JWT, hashing
│   │   ├── logging.py            # Logging centralizado
│   │   └── exceptions.py         # Exception handlers globales
│   ├── db/
│   │   ├── base.py               # Base declarativa SQLAlchemy
│   │   └── session.py            # Session factory
│   ├── models/                   # Modelos SQLAlchemy
│   │   ├── user.py               # Usuario
│   │   ├── otp.py                # Verificación OTP
│   │   ├── role.py               # Roles y permisos
│   │   ├── banco.py              # Bancos
│   │   ├── documento.py          # DocumentoS3 (metadata archivos)
│   │   ├── analisis.py           # AnalisisHipotecario
│   │   └── propuesta.py          # PropuestaAhorro
│   ├── repositories/             # Capa de acceso a datos
│   │   ├── users_repo.py
│   │   └── otp_repo.py
│   ├── schemas/                  # Pydantic schemas (DTOs)
│   │   ├── auth.py
│   │   └── user.py
│   └── services/                 # Lógica de negocio
│       ├── email_otp_service.py  # Envío de OTP por email
│       ├── pdf_service.py        # Procesamiento PDFs
│       ├── gemini_service.py     # Integración IA (esqueleto)
│       ├── calc_service.py       # Cálculos financieros
│       └── cleanup_service.py    # Limpieza usuarios PENDING
├── alembic/                      # Migraciones de DB
├── requirements.txt              # Dependencias Python
└── .env                          # Variables de entorno (no versionado)
```

## 🔒 Seguridad Implementada

### Autenticación
- ✅ JWT con expiración configurable
- ✅ HTTPBearer authentication
- ✅ Validación de estado ACTIVE del usuario
- ✅ Hashing de passwords con bcrypt

### Autorización
- ✅ Sistema RBAC (Role-Based Access Control)
- ✅ Decorador `require_role()` para protección granular
- ✅ Verificación de roles en cada request

### Integridad
- ✅ Constraints DB (unique email/identificación)
- ✅ Exception handlers para IntegrityError
- ✅ Rollback automático en transacciones fallidas
- ✅ SHA-256 checksum para archivos

### Resiliencia
- ✅ BackgroundTasks para operaciones I/O
- ✅ Cleanup automático de usuarios PENDING (10 min)
- ✅ Timeouts en conexiones SMTP
- ✅ Logging estructurado con niveles

## 📝 Flujo de Registro y Autenticación

```mermaid
sequenceDiagram
    User->>API: POST /auth/register
    API->>DB: Crear usuario (status=PENDING)
    API->>DB: Crear OTP
    API->>BackgroundTask: Enviar email con código
    API-->>User: 200 OK (user_id, message)
    BackgroundTask->>SMTP: Enviar email
    User->>API: POST /auth/verify-otp
    API->>DB: Validar código
    API->>DB: Actualizar usuario (status=ACTIVE)
    API-->>User: 200 OK (cuenta activada)
    User->>API: POST /auth/login
    API->>DB: Validar credenciales
    API-->>User: 200 OK (access_token)
```

## 🧪 Testing

### Validación Rápida
```bash
python validate_refactor.py
```

### Tests Unitarios (pendiente implementación)
```bash
pytest app/tests/
```

## 🐛 Troubleshooting

### Error: "Import PyPDF2 could not be resolved"
```bash
pip install PyPDF2==3.0.1
```

### Error: "6 validation errors for Settings"
- Falta el archivo `.env` o faltan variables requeridas
- Copia `.env.example` a `.env` y completa las variables

### Error SMTP: "Authentication failed"
- Para Gmail: Usa "App Password", no la contraseña normal
- Genera en: https://myaccount.google.com/apppasswords
- Habilita "Less secure app access" si usas otro proveedor

### Error: "Connection refused" (PostgreSQL)
```bash
# Verificar que PostgreSQL esté corriendo
docker-compose ps

# Iniciar PostgreSQL
docker-compose up -d postgres
```

## 📦 Dependencias Principales

```txt
fastapi==0.115.0          # Framework web
uvicorn[standard]         # ASGI server
SQLAlchemy==2.0.34        # ORM
psycopg2-binary           # Driver PostgreSQL
pydantic==2.9.2           # Validación datos
python-jose==3.3.0        # JWT
passlib[bcrypt]           # Hashing passwords
PyPDF2==3.0.1             # Procesamiento PDFs
apscheduler==3.10.4       # Background jobs
```

## 🚧 Pendientes de Implementación

- [ ] Integración Gemini API (extracción JSON de PDFs)
- [ ] Endpoints de análisis (upload, list, detail)
- [ ] Storage S3 o filesystem local
- [ ] Servicio de cálculos financieros completo
- [ ] Rate limiting con slowapi
- [ ] Tests unitarios e integración
- [ ] Matching de nombres con rapidfuzz

## 📄 Licencia

Propietario - EcoFinanzas © 2026

## 👥 Contacto

Para soporte técnico o consultas sobre el proyecto, contacta al equipo de desarrollo.
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\REFACTORING_SUMMARY.md
===============================
# 🏗️ Refactorización Arquitectura Senior - EcoFinanzas Backend

## ✅ Tareas Completadas

### 📋 Tarea 1: Refactor de Auth & Users - COMPLETADO

#### Dependencias de Seguridad (`app/api/deps.py`)
- ✅ **`get_current_user()`**: Decodifica JWT, valida expiración, verifica usuario ACTIVE
- ✅ **`require_role(*roles)`**: Decorator/dependencia para verificar roles específicos
- ✅ Protección completa con `HTTPBearer` authentication
- ✅ Manejo de excepciones 401 (token inválido) y 403 (usuario inactivo/sin permisos)

#### Endpoints de Usuarios (`app/api/v1/users.py`)
- ✅ **GET `/api/v1/users/me`**: Obtener perfil del usuario autenticado
  - Retorna: identificación, nombre completo, género, email, teléfono, status
  - Protegido con `get_current_user`
  
- ✅ **PATCH `/api/v1/users/me/password`**: Actualizar contraseña
  - Requiere contraseña actual para validación
  - Valida que nueva contraseña sea diferente
  - Hash seguro con bcrypt

#### Schemas (`app/schemas/user.py`)
- ✅ `UserProfileResponse`: Schema de respuesta de perfil
- ✅ `UpdatePasswordRequest`: Schema para cambio de contraseña

---

### 🔄 Tarea 2: Capa de Servicios & Background - COMPLETADO

#### Refactor EmailOtpService (`app/services/email_otp_service.py`)
- ✅ Método estático para uso directo en BackgroundTasks
- ✅ Logging robusto con niveles INFO/ERROR
- ✅ Manejo de excepciones SMTP con retorno bool (no bloquea con raise)
- ✅ Timeout de 10s en conexión SMTP
- ✅ Mensajes profesionales con detalles de expiración

#### Endpoint de Registro Asíncrono (`app/api/v1/auth.py`)
- ✅ Importación de `BackgroundTasks` y `IntegrityError`
- ✅ Envío de email en background con `background_tasks.add_task()`
- ✅ Captura de `IntegrityError` para constraints duplicados
- ✅ Respuestas HTTP específicas para email/identificación duplicados
- ✅ Rollback automático en caso de error

---

### 📦 Tarea 3: Estructura para PDFs - COMPLETADO

#### Modelos SQLAlchemy

**`app/models/banco.py`**
- ✅ Modelo `Banco` con id y nombre único

**`app/models/documento.py`**
- ✅ Modelo `DocumentoS3` completo:
  - Metadata: s3_key, original_filename, file_size, mime_type
  - Seguridad: pdf_encrypted, checksum_sha256
  - Estado: status (UPLOADED, PROCESSING, COMPLETED, FAILED)
  - Relaciones: usuario_id, banco_id

**`app/models/analisis.py`**
- ✅ Modelo `AnalisisHipotecario` completo:
  - Datos del usuario: ingresos_mensuales, capacidad_pago_max, tipo_contrato
  - Datos del crédito: numero_credito, valor_prestado, cuotas, saldo_capital
  - Beneficios: beneficio_frech_mensual, ajuste_inflacion_pesos
  - Validaciones: es_analisis_real, validado_por_sistema
  - JSON flexible: datos_manuales_json (JSONB)

**`app/models/propuesta.py`**
- ✅ Modelo `PropuestaAhorro` completo:
  - Opciones: numero_opcion, abono_adicional
  - Resultados: cuotas_reducidas, tiempo_ahorrado, valor_ahorrado_intereses
  - Financiero: honorarios_calculados, ingreso_minimo_requerido
  - Origen: USER o ADMIN

#### Servicios

**`app/services/pdf_service.py`** - COMPLETO
- ✅ **`is_pdf_encrypted()`**: Detecta si PDF tiene contraseña con PyPDF2
- ✅ **`decrypt_pdf()`**: Intenta desencriptar con password proporcionado
- ✅ **`calculate_checksum()`**: SHA-256 para integridad de archivos
- ✅ **`extract_text_basic()`**: Extracción básica con PyPDF2 (pre-Gemini)
- ✅ **`validate_credit_analysis_keywords()`**: Valida keywords de crédito
  - Detecta: crédito, préstamo, cuota, capital, interés, amortización, etc.
  - Score de confianza basado en matches

**`app/services/gemini_service.py`** - ESQUELETO PREPARADO
- ✅ Clase base con estructura para Gemini 1.5 Pro/Flash
- ✅ **`extract_credit_analysis()`**: Placeholder para extracción JSON
- ✅ **`validate_document_authenticity()`**: Placeholder para validación IA
- ✅ **`compare_names()`**: Placeholder para matching de nombres
- 📝 TODO: Integrar `google-generativeai` SDK cuando esté listo

#### Dependencias
- ✅ Agregado `PyPDF2==3.0.1` a `requirements.txt`

---

### ⚠️ Tarea 4: Manejo Global de Errores - COMPLETADO

#### Exception Handlers (`app/core/exceptions.py`)
- ✅ **`ErrorResponse`**: Clase para respuestas estandarizadas
- ✅ **`integrity_error_handler`**: Captura constraints DB
  - Detecta: duplicados (email, identificación), foreign keys, not null
  - Retorna 409 CONFLICT o 400 BAD_REQUEST según caso
  
- ✅ **`operational_error_handler`**: Maneja errores de conexión DB
  - Retorna 503 SERVICE_UNAVAILABLE
  
- ✅ **`data_error_handler`**: Maneja formatos inválidos
  - Retorna 400 BAD_REQUEST
  
- ✅ **`validation_error_handler`**: Formatea errores Pydantic
  - Retorna 422 UNPROCESSABLE_ENTITY con detalles legibles
  
- ✅ **`generic_exception_handler`**: Catch-all para excepciones no controladas
  - Logging con stack trace
  - Retorna 500 INTERNAL_SERVER_ERROR

#### Registro en Main (`app/main.py`)
- ✅ Importaciones de handlers y excepciones SQLAlchemy
- ✅ Registrados todos los handlers con `app.add_exception_handler()`
- ✅ Título actualizado: "EcoFinanzas Credit Analysis API"
- ✅ Descripción y versión agregadas

---

## 📊 Estructura Final del Backend

```
backend/
├── app/
│   ├── main.py                    ✅ Refactorizado con exception handlers
│   ├── api/
│   │   ├── deps.py               ✅ get_current_user + require_role
│   │   └── v1/
│   │       ├── router.py         ✅ Incluye users router
│   │       ├── auth.py           ✅ BackgroundTasks + IntegrityError
│   │       └── users.py          ✅ /me endpoints implementados
│   ├── core/
│   │   ├── config.py             ✅ Settings
│   │   ├── security.py           ✅ JWT + hashing
│   │   └── exceptions.py         ✅ NUEVO: Exception handlers globales
│   ├── models/
│   │   ├── user.py               ✅ Existente
│   │   ├── otp.py                ✅ Existente
│   │   ├── role.py               ✅ Existente
│   │   ├── banco.py              ✅ NUEVO
│   │   ├── documento.py          ✅ NUEVO: DocumentoS3
│   │   ├── analisis.py           ✅ NUEVO: AnalisisHipotecario
│   │   └── propuesta.py          ✅ NUEVO: PropuestaAhorro
│   ├── repositories/
│   │   ├── users_repo.py         ✅ Existente
│   │   └── otp_repo.py           ✅ Existente
│   ├── schemas/
│   │   ├── auth.py               ✅ Existente
│   │   └── user.py               ✅ NUEVO: UserProfile + UpdatePassword
│   └── services/
│       ├── email_otp_service.py  ✅ Refactorizado (async-ready)
│       ├── pdf_service.py        ✅ NUEVO: Detección + extracción
│       ├── gemini_service.py     ✅ NUEVO: Esqueleto para IA
│       └── cleanup_service.py    ✅ Existente
└── requirements.txt              ✅ Actualizado con PyPDF2
```

---

## 🔐 Seguridad Implementada

### Autenticación y Autorización
- ✅ JWT con expiración configurable
- ✅ Validación de usuario ACTIVE en cada request protegido
- ✅ Sistema de roles (CLIENT, ADMIN) con verificación granular
- ✅ HTTPBearer authentication en todos los endpoints privados

### Integridad de Datos
- ✅ Constraints de DB (unique email/identificación) con manejo robusto
- ✅ Hash SHA-256 para checksums de archivos
- ✅ Detección de PDFs encriptados antes de procesamiento
- ✅ Validación de contraseña actual antes de actualizar

### Resiliencia
- ✅ BackgroundTasks para operaciones I/O (email)
- ✅ Rollback automático en transacciones fallidas
- ✅ Exception handlers globales con logging
- ✅ Timeouts en conexiones SMTP

---

## 🚀 Próximos Pasos Sugeridos

### Alta Prioridad
1. **Integrar Gemini API**
   - Instalar `google-generativeai`
   - Implementar prompts para extracción JSON
   - Configurar API key en settings

2. **Implementar Endpoints de Análisis**
   - POST `/api/v1/analyses/upload` (Cliente)
   - GET `/api/v1/analyses/` (Admin - listar todos)
   - GET `/api/v1/analyses/{id}` (Cliente - ver propio)
   - POST `/api/v1/analyses/{id}/recalculate` (Admin)

3. **Storage (S3 o Local)**
   - Implementar `s3_service.py` con boto3 o filesystem local
   - Generar URLs prefirmadas para descargas seguras

4. **Servicio de Cálculos**
   - Completar `calc_service.py` con fórmulas financieras
   - Algoritmos para nuevas oportunidades de ahorro
   - Cálculo de honorarios e ingresos mínimos

### Media Prioridad
5. **Tests**
   - Tests unitarios para servicios (pdf, calc)
   - Tests de integración para endpoints
   - Fixtures en `conftest.py`

6. **Rate Limiting**
   - Instalar `slowapi`
   - Limitar endpoints de OTP y upload

7. **Admin Panel Features**
   - Filtros por fecha/cédula/número crédito
   - Exportación a Excel/PDF de propuestas

### Baja Prioridad
8. **Auditoría**
   - Modelo de auditoría para tracking de cambios
   - Logs de acciones sensibles

9. **Notificaciones**
   - Email cuando análisis esté listo
   - Notificaciones a admin de nuevos uploads

---

## 🧪 Testing Básico

### Endpoints para Probar

**Auth**
```bash
# Registro
POST /api/v1/auth/register
{
  "nombres": "Juan",
  "primer_apellido": "Pérez",
  "tipo_identificacion": "CC",
  "identificacion": "1234567890",
  "email": "juan@example.com",
  "password": "Test1234!",
  "genero": "M"
}

# Verificar OTP
POST /api/v1/auth/verify-otp
{
  "user_id": "uuid-aqui",
  "code": "123456"
}

# Login
POST /api/v1/auth/login
{
  "identificacion": "1234567890",
  "password": "Test1234!"
}
```

**Users (requiere token)**
```bash
# Ver perfil
GET /api/v1/users/me
Authorization: Bearer <token>

# Cambiar contraseña
PATCH /api/v1/users/me/password
Authorization: Bearer <token>
{
  "current_password": "Test1234!",
  "new_password": "NewPass456!"
}
```

---

## 📝 Notas Importantes

### ⚠️ Consideraciones de Producción
- **SMTP**: Considerar usar SendGrid/Mailgun en vez de SMTP directo
- **File Storage**: Implementar S3 privado con presigned URLs
- **Secrets**: Usar gestores de secretos (AWS Secrets Manager, Vault)
- **Logging**: Integrar Sentry o similar para monitoreo
- **CORS**: Configurar origins permitidos para frontend

### 🔧 Variables de Entorno Requeridas
```env
DATABASE_URL=postgresql://user:pass@localhost/dbname
SECRET_KEY=tu-secret-key-seguro
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=tu-email@gmail.com
SMTP_PASSWORD=tu-app-password
SMTP_FROM_EMAIL=noreply@ecofinanzas.com
SMTP_FROM_NAME=EcoFinanzas
```

### 📚 Librerías Adicionales Sugeridas
```txt
# Para implementar próximamente
google-generativeai>=0.3.0  # Gemini API
boto3>=1.34.0               # AWS S3
slowapi>=0.1.9              # Rate limiting
rapidfuzz>=3.6.0            # Name matching
openpyxl>=3.1.0            # Excel export
celery>=5.3.0              # Background jobs (escalado)
```

---

## ✅ Checklist de Completitud

- [x] Dependencias de seguridad (get_current_user, require_role)
- [x] Endpoints de usuarios (/me, /me/password)
- [x] BackgroundTasks para emails
- [x] Modelos de documento, análisis y propuestas
- [x] Servicio de PDF (detección contraseña, extracción)
- [x] Servicio Gemini (esqueleto)
- [x] Exception handlers globales
- [x] Manejo de IntegrityError
- [x] Requirements.txt actualizado
- [x] Main.py con handlers registrados
- [x] Logging estructurado
- [ ] Endpoints de análisis (pendiente)
- [ ] Integración Gemini real (pendiente)
- [ ] Storage S3 (pendiente)
- [ ] Cálculos financieros (pendiente)
- [ ] Tests (pendiente)

---

**Estado actual: Backend 40% completo**  
**Infraestructura de seguridad: 100% ✅**  
**Modelos de datos: 90% ✅**  
**Servicios core: 60% ✅**  
**APIs de negocio: 20% 🚧**
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\requirements.txt
===============================
fastapi==0.115.0
uvicorn[standard]==0.30.6
SQLAlchemy==2.0.34
psycopg2-binary==2.9.9
pydantic==2.9.2
pydantic-settings==2.5.2
python-jose==3.3.0
passlib[bcrypt]==1.7.4
bcrypt==4.0.1  # <-- ES VITAL QUE SEA ESTA VERSIÓN
python-multipart==0.0.9
email-validator==2.2.0
apscheduler==3.10.4
PyPDF2==3.0.1  # Para detección de PDFs encriptados y extracción básica
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\validate_refactor.py
===============================
"""
Script de validación rápida para verificar imports y estructura.
NO ejecuta el servidor, solo valida sintaxis y dependencias.
"""
import sys
from pathlib import Path

# Agregar el directorio raíz al path
sys.path.insert(0, str(Path(__file__).parent))

def test_imports():
    """Verifica que todos los módulos se importen correctamente"""
    print("🔍 Validando imports...")
    
    try:
        # Core
        from app.core.config import settings
        from app.core.security import hash_password, verify_password, create_access_token
        from app.core.exceptions import ErrorResponse
        print("✅ Core imports OK")
        
        # Database
        from app.db.base import Base
        from app.db.session import SessionLocal
        print("✅ Database imports OK")
        
        # Models
        from app.models.user import Usuario
        from app.models.otp import VerificacionOTP
        from app.models.role import Role, UsuarioRole
        from app.models.banco import Banco
        from app.models.documento import DocumentoS3
        from app.models.analisis import AnalisisHipotecario
        from app.models.propuesta import PropuestaAhorro
        print("✅ Models imports OK")
        
        # Repositories
        from app.repositories.users_repo import UsersRepo
        from app.repositories.otp_repo import OtpRepo
        print("✅ Repositories imports OK")
        
        # Schemas
        from app.schemas.auth import RegisterRequest, LoginRequest, TokenResponse
        from app.schemas.user import UserProfileResponse, UpdatePasswordRequest
        print("✅ Schemas imports OK")
        
        # Services (algunos tienen dependencias externas que faltan)
        from app.services.email_otp_service import EmailOtpService
        from app.services.cleanup_service import cleanup_expired_pending_users
        from app.services.gemini_service import GeminiService
        print("✅ Services imports OK (excepto pdf_service - PyPDF2 pendiente)")
        
        # API
        from app.api.deps import get_db, get_current_user, require_role
        from app.api.v1.router import api_router
        print("✅ API imports OK")
        
        # Main app
        from app.main import app
        print("✅ Main app import OK")
        
        return True
        
    except ImportError as e:
        print(f"❌ Import error: {e}")
        return False
    except Exception as e:
        print(f"❌ Error: {e}")
        return False


def test_security_functions():
    """Prueba las funciones de seguridad básicas"""
    print("\n🔐 Validando funciones de seguridad...")
    
    try:
        from app.core.security import hash_password, verify_password
        
        # Test hashing
        password = "Test1234!"
        hashed = hash_password(password)
        assert len(hashed) > 0, "Hash vacío"
        assert hashed != password, "Hash no funciona"
        print(f"✅ Hash generado: {hashed[:30]}...")
        
        # Test verification
        assert verify_password(password, hashed), "Verificación falló"
        print("✅ Verificación de password OK")
        
        assert not verify_password("wrong_password", hashed), "Verificación debería fallar"
        print("✅ Rechazo de password incorrecta OK")
        
        return True
        
    except Exception as e:
        print(f"❌ Error en security: {e}")
        return False


def test_error_response():
    """Prueba la estructura de respuestas de error"""
    print("\n⚠️ Validando ErrorResponse...")
    
    try:
        from app.core.exceptions import ErrorResponse
        
        error = ErrorResponse.format(
            error_type="test_error",
            message="Test message",
            detail={"field": "test"},
            status_code=400
        )
        
        assert "error" in error
        assert "message" in error
        assert "status_code" in error
        assert error["error"] == "test_error"
        print("✅ ErrorResponse format OK")
        
        return True
        
    except Exception as e:
        print(f"❌ Error en ErrorResponse: {e}")
        return False


def main():
    print("=" * 60)
    print("🧪 VALIDACIÓN DE REFACTORIZACIÓN - EcoFinanzas Backend")
    print("=" * 60)
    
    results = []
    
    # Test 1: Imports
    results.append(("Imports", test_imports()))
    
    # Test 2: Security
    results.append(("Security Functions", test_security_functions()))
    
    # Test 3: Error Response
    results.append(("Error Response", test_error_response()))
    
    # Resumen
    print("\n" + "=" * 60)
    print("📊 RESUMEN DE VALIDACIÓN")
    print("=" * 60)
    
    passed = sum(1 for _, result in results if result)
    total = len(results)
    
    for test_name, result in results:
        status = "✅ PASS" if result else "❌ FAIL"
        print(f"{status} - {test_name}")
    
    print("\n" + "=" * 60)
    print(f"Resultado: {passed}/{total} tests pasaron")
    
    if passed == total:
        print("🎉 ¡VALIDACIÓN EXITOSA! El código está listo.")
        print("\n📝 Notas:")
        print("  - PyPDF2 no instalado (esperado)")
        print("  - Para ejecutar: pip install -r requirements.txt")
        print("  - Luego: uvicorn app.main:app --reload")
    else:
        print("⚠️ Algunos tests fallaron. Revisa los errores arriba.")
    
    print("=" * 60)
    
    return passed == total


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)===============================
C:\Proyectos en desarrollo\credit-analysis\backend\alembic.ini
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\requirements.txt
===============================
fastapi==0.115.0
uvicorn[standard]==0.30.6

SQLAlchemy==2.0.34
psycopg2-binary==2.9.9

pydantic==2.9.2
pydantic-settings==2.5.2

python-jose==3.3.0
passlib[bcrypt]==1.7.4

python-multipart==0.0.9
email-validator==2.2.0
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\alembic\env.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\main.py
===============================
from fastapi import FastAPI
from app.api.v1.router import api_router

app = FastAPI(title="Credit Analysis API")

app.include_router(api_router, prefix="/api/v1")
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\deps.py
===============================
from app.db.session import SessionLocal

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\admin.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\analyses.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\auth.py
===============================
import secrets
import uuid
from datetime import datetime, timedelta, timezone

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.api.deps import get_db
from app.core.config import settings
from app.core.security import hash_password, verify_password, create_access_token
from app.models.user import Usuario
from app.models.otp import VerificacionOTP
from app.repositories.users_repo import UsersRepo
from app.repositories.otp_repo import OtpRepo
from app.services.email_otp_service import EmailOtpService
from app.schemas.auth import (
    RegisterRequest,
    RegisterResponse,
    VerifyOtpRequest,
    LoginRequest,
    TokenResponse,
)

router = APIRouter()


@router.post("/register", response_model=dict)
def register(payload: RegisterRequest, db: Session = Depends(get_db)):
    users = UsersRepo(db)

    # Validaciones de unicidad
    if users.get_by_email(str(payload.email)):
        raise HTTPException(status_code=409, detail="El email ya estÃ¡ registrado.")
    if users.get_by_identificacion(payload.identificacion):
        raise HTTPException(status_code=409, detail="La identificaciÃ³n ya estÃ¡ registrada.")

    # Crear usuario
    user = Usuario(
        nombres=payload.nombres,
        primer_apellido=payload.primer_apellido,
        segundo_apellido=payload.segundo_apellido,
        tipo_identificacion=payload.tipo_identificacion,
        identificacion=payload.identificacion,
        email=str(payload.email),
        telefono=payload.telefono,
        genero=payload.genero,
        password_hash=hash_password(payload.password),
        ciudad_id=payload.ciudad_id,
        status="PENDING",
        email_verificado=False,
    )

    user = users.create_user(user)
    users.ensure_role_assignment(user.id, "CLIENT")

    # Crear OTP
    code = f"{secrets.randbelow(1_000_000):06d}"
    expires = datetime.now(timezone.utc) + timedelta(minutes=settings.OTP_EXPIRE_MINUTES)

    otp_repo = OtpRepo(db)
    otp = VerificacionOTP(
        user_id=user.id,
        code_hash=hash_password(code),
        tipo="EMAIL",
        status="PENDING",
        expires_at=expires,
        used_at=None,
    )
    otp_repo.create(otp)

    # Asignar rol CLIENT
    try:
        users.ensure_role_assignment(user.id, "CLIENT")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error asignando rol CLIENT: {str(e)}")

    # Enviar email
    try:
        EmailOtpService().send_otp(to_email=str(payload.email), code=code)
    except Exception:
        raise HTTPException(status_code=500, detail="No se pudo enviar el OTP al correo.")

    return RegisterResponse(
        user_id=str(user.id),
        status=user.status,
        message="Usuario creado en estado PENDING. Verifica el OTP enviado al correo para activar tu cuenta.",
    ).model_dump()


@router.post("/verify-otp", response_model=dict)
def verify_otp(payload: VerifyOtpRequest, db: Session = Depends(get_db)):
    users = UsersRepo(db)
    otp_repo = OtpRepo(db)

    # Parse user_id a UUID
    try:
        user_id = uuid.UUID(payload.user_id)
    except Exception:
        raise HTTPException(status_code=400, detail="user_id invÃ¡lido.")

    user = users.get_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no existe.")

    otp = otp_repo.get_pending(user_id=user.id, tipo="EMAIL")
    if not otp:
        raise HTTPException(status_code=400, detail="No hay OTP pendiente para este usuario.")

    now = datetime.now(timezone.utc)

    if otp.expires_at and now > otp.expires_at:
        otp.status = "EXPIRED"
        otp_repo.save(otp)
        raise HTTPException(status_code=400, detail="OTP expirado. Solicita uno nuevo.")

    if not otp.code_hash or not verify_password(payload.code, otp.code_hash):
        raise HTTPException(status_code=400, detail="OTP incorrecto.")

    otp.status = "VERIFIED"
    otp.used_at = now
    otp_repo.save(otp)

    user.email_verificado = True
    user.status = "ACTIVE"
    db.add(user)
    db.commit()
    db.refresh(user)

    return {"message": "Cuenta verificada. Ya puedes iniciar sesiÃ³n.", "status": user.status}


@router.post("/login", response_model=dict)
def login(payload: LoginRequest, db: Session = Depends(get_db)):
    users = UsersRepo(db)
    user = users.get_by_identificacion(payload.identificacion)

    if not user or not user.password_hash or not verify_password(payload.password, user.password_hash):
        raise HTTPException(status_code=401, detail="Credenciales invÃ¡lidas.")

    if user.status != "ACTIVE" or not user.email_verificado:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cuenta no activa. Verifica tu correo con OTP.",
        )

    token = create_access_token(subject=str(user.id))
    return TokenResponse(access_token=token).model_dump()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\documents.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\router.py
===============================
from fastapi import APIRouter
from app.api.v1.auth import router as auth_router

api_router = APIRouter()
api_router.include_router(auth_router, prefix="/auth", tags=["auth"])
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\api\v1\users.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\config.py
===============================
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str

    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    OTP_EXPIRE_MINUTES: int = 10

    SMTP_HOST: str
    SMTP_PORT: int = 587
    SMTP_USER: str
    SMTP_PASSWORD: str
    SMTP_FROM_NAME: str = "Credit Analysis"
    SMTP_FROM_EMAIL: str

    APP_PUBLIC_NAME: str = "Credit Analysis"

    class Config:
        env_file = ".env"


settings = Settings()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\exceptions.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\logging.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\core\security.py
===============================
from datetime import datetime, timedelta, timezone
from jose import jwt
from passlib.context import CryptContext
from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


def create_access_token(subject: str) -> str:
    expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    payload = {"sub": subject, "exp": expire}
    return jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\db\base.py
===============================
from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    pass
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\db\session.py
===============================
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\analisis.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\auditoria.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\banco.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\documento.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\opcion_abono.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\otp.py
===============================
import uuid
from sqlalchemy import String, DateTime, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class VerificacionOTP(Base):
    __tablename__ = "verificaciones_otp"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, server_default=text("gen_random_uuid()"))
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("usuarios.id", ondelete="CASCADE"), nullable=False)

    code_hash: Mapped[str | None] = mapped_column(String(255))
    tipo: Mapped[str | None] = mapped_column(String(20))  # EMAIL
    status: Mapped[str] = mapped_column(String(20), server_default=text("'PENDING'"))  # PENDING/VERIFIED/EXPIRED

    expires_at: Mapped[str | None] = mapped_column(DateTime(timezone=True))
    used_at: Mapped[str | None] = mapped_column(DateTime(timezone=True))
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\propuesta.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\role.py
===============================
import uuid
from sqlalchemy import String, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class Role(Base):
    __tablename__ = "roles"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    code: Mapped[str | None] = mapped_column(String(30), unique=True)
    name: Mapped[str | None] = mapped_column(String(80))


class UsuarioRole(Base):
    __tablename__ = "usuario_roles"

    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("usuarios.id", ondelete="CASCADE"), primary_key=True)
    role_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("roles.id", ondelete="CASCADE"), primary_key=True)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\user.py
===============================
import uuid
from sqlalchemy import String, Boolean, DateTime, ForeignKey, text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base


class Usuario(Base):
    __tablename__ = "usuarios"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, server_default=text("gen_random_uuid()"))
    nombres: Mapped[str | None] = mapped_column(String(150))
    primer_apellido: Mapped[str | None] = mapped_column(String(80))
    segundo_apellido: Mapped[str | None] = mapped_column(String(80))
    tipo_identificacion: Mapped[str | None] = mapped_column(String(10))
    identificacion: Mapped[str | None] = mapped_column(String(30), unique=True)
    email: Mapped[str | None] = mapped_column(String(255), unique=True)
    telefono: Mapped[str | None] = mapped_column(String(30))
    genero: Mapped[str | None] = mapped_column(String(20))
    password_hash: Mapped[str | None] = mapped_column(String(255))

    ciudad_id: Mapped[int | None] = mapped_column(ForeignKey("ciudades.id", ondelete="SET NULL"), nullable=True)

    status: Mapped[str] = mapped_column(String(20), server_default=text("'PENDING'"))
    email_verificado: Mapped[bool] = mapped_column(Boolean, server_default=text("false"))
    created_at: Mapped[str | None] = mapped_column(DateTime(timezone=True), server_default=text("now()"))
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\models\__init__.py
===============================
from app.models.user import Usuario
from app.models.role import Role, UsuarioRole
from app.models.otp import VerificacionOTP
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\admin_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\analyses_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\documents_repo.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\otp_repo.py
===============================
from sqlalchemy.orm import Session
from sqlalchemy import select
from app.models.otp import VerificacionOTP


class OtpRepo:
    def __init__(self, db: Session):
        self.db = db

    def create(self, otp: VerificacionOTP) -> VerificacionOTP:
        self.db.add(otp)
        self.db.commit()
        self.db.refresh(otp)
        return otp

    def get_pending(self, user_id, tipo: str) -> VerificacionOTP | None:
        return self.db.execute(
            select(VerificacionOTP)
            .where(
                VerificacionOTP.user_id == user_id,
                VerificacionOTP.tipo == tipo,
                VerificacionOTP.status == "PENDING",
            )
            .order_by(VerificacionOTP.expires_at.desc())
        ).scalar_one_or_none()

    def save(self, otp: VerificacionOTP):
        self.db.add(otp)
        self.db.commit()
        self.db.refresh(otp)
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\repositories\users_repo.py
===============================
from sqlalchemy.orm import Session
from sqlalchemy import select
from app.models.user import Usuario
from app.models.role import Role, UsuarioRole


class UsersRepo:
    def __init__(self, db: Session):
        self.db = db

    def get_by_email(self, email: str) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.email == email)).scalar_one_or_none()

    def get_by_identificacion(self, identificacion: str) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.identificacion == identificacion)).scalar_one_or_none()

    def get_by_id(self, user_id) -> Usuario | None:
        return self.db.execute(select(Usuario).where(Usuario.id == user_id)).scalar_one_or_none()

    def create_user(self, user: Usuario) -> Usuario:
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user

    def ensure_role_assignment(self, user_id, role_code: str):
        role = self.db.execute(select(Role).where(Role.code == role_code)).scalar_one_or_none()
        if not role:
            raise ValueError(f"Role {role_code} no existe (seed roles).")

        exists = self.db.execute(
            select(UsuarioRole).where(UsuarioRole.user_id == user_id, UsuarioRole.role_id == role.id)
        ).scalar_one_or_none()

        if not exists:
            self.db.add(UsuarioRole(user_id=user_id, role_id=role.id))
            self.db.commit()
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\analisis.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\auth.py
===============================
from pydantic import BaseModel, EmailStr, Field


class RegisterRequest(BaseModel):
    nombres: str = Field(min_length=1, max_length=150)
    primer_apellido: str = Field(min_length=1, max_length=80)
    segundo_apellido: str | None = Field(default=None, max_length=80)

    tipo_identificacion: str = Field(min_length=1, max_length=10)
    identificacion: str = Field(min_length=3, max_length=30)

    email: EmailStr
    telefono: str | None = Field(default=None, max_length=30)
    genero: str | None = Field(default=None, max_length=20)

    password: str = Field(min_length=8, max_length=72)

    ciudad_id: int | None = None


class RegisterResponse(BaseModel):
    user_id: str
    status: str
    message: str


class VerifyOtpRequest(BaseModel):
    user_id: str
    code: str = Field(min_length=4, max_length=12)


class LoginRequest(BaseModel):
    identificacion: str
    password: str


class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\documentos.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\propuestas.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\schemas\user.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\calc_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\email_otp_service.py
===============================
import smtplib
from email.mime.text import MIMEText
from app.core.config import settings


class EmailOtpService:
    def send_otp(self, to_email: str, code: str):
        subject = f"{settings.APP_PUBLIC_NAME} - CÃ³digo de verificaciÃ³n"
        body = f"Tu cÃ³digo OTP es: {code}\n\nVence en {settings.OTP_EXPIRE_MINUTES} minutos."

        msg = MIMEText(body, "plain", "utf-8")
        msg["Subject"] = subject
        msg["From"] = f"{settings.SMTP_FROM_NAME} <{settings.SMTP_FROM_EMAIL}>"
        msg["To"] = to_email

        with smtplib.SMTP(settings.SMTP_HOST, settings.SMTP_PORT) as server:
            server.starttls()
            server.login(settings.SMTP_USER, settings.SMTP_PASSWORD)
            server.sendmail(settings.SMTP_FROM_EMAIL, [to_email], msg.as_string())
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\gemini_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\pdf_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\s3_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\services\validation_service.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\conftest.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_admin_filters.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_auth.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\tests\test_upload.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\dates.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\hashing.py
===============================
===============================
C:\Proyectos en desarrollo\credit-analysis\backend\app\utils\money.py
===============================
